---
layout: bt_wiki
title: Security Guide
category: Guides
publish: true
abstract: Cloudify's Management security configuration and client usage
pageord: 500

---
{%summary%} {{page.abstract}}{%endsummary%}

# Overview

This guide will explain how to bootstrap a secured manager and use it from the CLI and web UI. <br/>
Securing the manager focuses on the REST service, which is the access point of all clients to the management server.

Cloudify's security framework uses the [Flask-secuREST](https://github.com/cloudify-cosmo/flask-securest/tree/0.6)
package, which integrates with [Flask-RESTful](https://flask-restful.readthedocs.org/en/0.3.2/) to secure REST services.

When security is enabled, all requests to the REST service are authenticated before they can reach their endpoint.
For example, when a user of the Web-UI attempts to see the all blueprints, a request is sent to the REST service
"blueprints" endpoint, but it will only reach it if the user is logged in with valid credentials. <br/>
Similarly, the CLI command "cfy deployments create" will only be successful if valid
username and password are sent with the REST call to the endpoint "deployments".
Of course, direct requests made using other clients (e.g. curl) must also include correct credentials, or they will
fail with an "Unauthorized User" error.


# Main Concepts

## Userstore
Generally, a userstore is simply a class that enables loading of user details and returns them as a user object.

Typically (but not always) user details are stored as records in a database or objects in a directory. Each user can
be identified by a unique attribute, such as a username or id, or by a unique combination of attributes.<br/>
In order to authenticate a user (for example by a set of username and password) it might be required to load the user's
details and verify the given credentials indeed match.<br/>
To support a variety of user-store systems and configurations Cloudify security framework can accept different
userstore implementations. It's possible to use the default Flask-secuREST simple userstore or to specify a new
implementation that supports a specific userstore system.

A valid userstore implementation can be any Python class that inherits from
[abstract_userstore.py](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/userstores/
abstract_userstore.py) and implements a `get_user` method.
The object returned by `get_user` must adhere to Flask-secuREST's User Model, specifying these 3 methods:

- is_active()
- is_anonymous()
- get_roles()


## Authentication Provider
An Authentication Provider is a class that performs authentication. Multiple authentication providers can be configured
in order to support different authentication methods (e.g. password, token, Kerberos).<br/>
When a REST call is received by the REST service, the security framework will attempt to authenticate it using each
authentication provider in the order of configuration, until authentication succeeds.
The authentication provider has access to the userstore instance (if configured) and can use it to get user details and
use them to perform authentication.<br/>
For example, it can compare the given password to the one found on the userstore or verify the user is still active
(in many environments users are marked as "inactive", instead of deleting the account entirely).


Once an authenticator can successfully authenticate the request's user - it should return the user object and allow the
request to be completed. Other authenticators will not be called until the next request is processed.
If non of the authenticators authenticates the request - the request will not reach its endpoint and the client will
receive an "Unauthorized User" error.

A valid authentication provider implementation can be any Python class that inherits from
[abstract_authentication_provider.py](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/
authentication_providers/abstract_authentication_provider.py) and implements an `authenticate` method.


## Token Generator
We mentioned Token as an authentication method. But in order to send a token with each request, the user must first
receive a token. Tokens can be generated by many systems, and they will work as long as the token can be processed by
one of the registered authentication providers.


To make things easier, Cloudify can also generate tokens through the REST service endpoint "/tokens".
To enable this feature a token generator must be configured.
{%note title=Note%}
The request to "MANAGER_IP/tokens" must itself be authenticated (using a username-password set, for example).
{%endnote%}


# Setting up a secured server

## Manager Blueprint Configuration
The security configuration is located in the manager blueprint, in this path:
node_templates --> manager --> properties --> cloudify --> security
Each setting is described in detail in the following sections.

### Setting Security On / Off
The first setting in the "security" path is:

{% highlight yaml %}
enabled: false
{% endhighlight %}

This means security is turned off. In order to activate the security framework set {% highlight yaml %}enabled: true{% endhighlight %}
Otherwise, all other security configuration will be ignored.

### Configuring Authentication Providers
In the manager blueprint, under `authentication_providers` is a list all the authenticators *In the order they should be executed*.<br/>
At least one authentication provider must be configured.

Each authentication provider must include these properties:

- name - a unique name describing this authenticator. This name will appear in logs so it should be clear.
- implementation - the fully qualified name of a module implementing an authentication provider, followed by ":" and
the class name.
- properties - a dictionary of arguments required to instantiate the authentication provider class. The arguments will
be passed as kwargs to the class' `__init__` method.

The default configuration lists two authenticators - password and token:

{% highlight yaml %}
authentication_providers:
  - name: password
    implementation: flask_securest.authentication_providers.password:PasswordAuthenticator
    properties:
      password_hash: plaintext
  - name: token
    implementation: flask_securest.authentication_providers.token:TokenAuthenticator
    properties:
      secret_key: my_secret
{% endhighlight %}

The above configuration will cause the security framework to instantiate two classes:

- Flask-secuREST's "PasswordAuthenticator", with the password_hash arguement set to "plaintext".
{%note title=Note%}
Passwords are usually not store as plaintext. Set the passowrd_hash to match the hash scheme used
in the selected userstore.
Possible values are: 'bcrypt', 'des_crypt', 'pbkdf2_sha256', pbkdf2_sha512', 'sha256_crypt' and 'sha512_crypt'.
{%endnote%}
This authentication check will be performed first for each request sent to the REST service. If it fails, the next
authenticator will be used.

- Flask-secuREST's "TokenAuthenticator", with the secret_key arguement set to "my_secret".
If (and only if) the password-based authentication failed, this authentication method will be executed as well.
The secret key is used to decrypt the token sent with the request, if a token was sent.
{%note title=Note%}
In the default configuration, the key used to authenticate a token must be the same as the key used to generate it.
{%endnote%}

It is possible to implement many other authentication providers, including providers that do not require accessing a
userstore directly (e.g. oAuth). This is explained later in this document.

### Configuring a Userstore
Under "userstore_driver" a single userstore is set:

- implementation - the fully qualified name of the module implementing a userstore integration, followed by ":" and the
class name.
- properties - a dictionary of arguments required to instantiate the implementing class. The arguments will be passed as
kwargs to the class' `__init__` method.

The default configuration uses Flask-secuREST's simple userstore, with a list of users in-line:

{% highlight yaml %}
userstore_driver:
  implementation: flask_securest.userstores.simple:SimpleUserstore
  properties:
    userstore:
      user1:
        username: example_user1
        password: example_password1
        email: example_user1@your_domain.dom
      user2:
        username: example_user2
        password: example_password2
        email: example_user2@your_domain.dom
      user3:
        username: example_user3
        password: example_password3
        email: example_user3@your_domain.dom
    identifying_attribute: username
{% endhighlight %}

In the default configuration a userstore is created on the fly, containing the 3 listed users. The identifying
attribute (by which a user can be identified) is set to "username".
This is a very simple implementation useful for demonstration. To integrate with a "real" userstore a different
implementation can be created and installed, as explained later.


### Configuring a Token Generator
In order to enable token generation through the REST "/tokens" endpoint a token generator must be configured:

- implementation - the fully qualified name of the module implementation token generation, followed by ":" and the
class name.
- properties - a dictionary of arguments required to instantiate the implementing class. The arguments will be passed as
kwargs to the class' `__init__` method.

The default configuration uses Flask-secuREST's token module to generate tokens:

{% highlight yaml %}
auth_token_generator:
  implementation: flask_securest.authentication_providers.token:TokenAuthenticator
  properties:
    secret_key: my_secret
    expires_in_seconds: 600
{% endhighlight %}

This configuration uses (as it must) the same secret key for token generation and for token authentication.
This configuration however includes the additional argument "expires_in_seconds" which limits the lifetime of a token
to 10 minutes. A token older than 10 minutes will therefore be "expired" and fail the request.


### SSL


### Logging
Security operations, such as authentication success or failure and user details, are logged to a dedicated log file on the management container.
The default log configuration is:

{% highlight yaml %}
log_file: /var/log/cloudify/rest-security-audit.log
log_level: INFO
{% endhighlight %}

Setting the log file location is pretty strait-forward.<br/>
Modifying the log level will produce less or more elaborate security auditing; The acceptable values are:
CRITICAL, ERROR, WARNING, INFO or DEBUG.

Other settings not included in the default configuration are:

- log_file_size_MB - limits the log file size. By default, the file is limited to 100 MB. When the file reaches that
size, it will be renamed with the extension ".1" and a new log file will be created.
- log_files_backup_count - sets the maximum number of old log files to keep. By default this value is set to 20. That
means that up to 20 old log files can be created, after which the oldest file will be removed.


# Clients

## Web UI
{%note title=Note%}
Available in the Commercial version only
{%endnote%}

## Cloudify CLI

## cURL

# Examples

## Simple - Using the default userstore driver and password authentication, no SSL

## Advanced - Using the default userstore driver and token authentication, with SSL


# Behind the Scenes / Advanced

## request-response flow

## Internal communication between the Cloudify manager and other Cloudify components

Currently, communication between the Cloudify agents and the Cloudify manager does not go through authentication - instead, REST calls from the agents to the manager are done to port 8101, which has the same general behavior as port 80, yet the REST service lets requests made to this port through without having them go through any of the security mechanisms.

The usage of this port, however, is restricted to components on the same subnet as the Cloudify manager alone. This is done using specific security group rules, which are set up during bootstrap (for example, see [this rule in the Openstack manager blueprint](https://github.com/cloudify-cosmo/cloudify-manager-blueprints/blob/master/openstack/openstack-manager-blueprint.yaml#L206)). It is therefore impossible to bypass the security mechanisms from outside the manager's internal network by making REST calls directly to the 8101 port.

In future versions, all communications from and to the Cloudify manager will utilize the security mechanisms, including communication with any of Cloudify's internal components, at which time, the bypass port 8101 will be removed.


## Advanced configuration (logs, token timeout, password hashing, nginx)

# Writing your own userstore and authentication providers

## how to write

## Packaging, Configuring and Installing Custom Implementations

In order to use custom implementations of userstores, authentication providers and token generators; the implementations themselves should be installed on the manager.

To do this, the manager blueprint should be updated as follows.

Say you write a custom authentication provider. The code itself should be structured in a similar way to how [operations/workflows](guide-plugin-creation.html#creating-a-plugin-project) plugins are structured, that is to say, it should be structured as a valid python package.

You specify the package location under the `plugins` section in the `cloudify` property of the `manager` node in the manager blueprint like this:
{% highlight yaml %}
node_templates:
  ...
  manager:
    ...
    properties:
      ...
      cloudify:
        plugins:
          my_authentication_provider:

            # see description below
            source: my-extensions/simple-authentication-provider

            # see description below
            install_args: '--pre'

          my_userstore:

            # see description below
            source: https://github.com/my-org/my-auth-provider/archive/master.zip

{% endhighlight %}


### Configuration
The `plugins` section is a dict that contains all plugins that should be installed.

The keys of this dict are arbitrary names. In the previous example we used `my_authentication_provider` and `my_userstore` as the names.

* `source` Can be any of the following:
  * A path to the package directory relative to the [main manager blueprint file](reference-terminology.html#main-blueprint-file) directory (e.g. `my-extensions/simple-authentication-provider`)
  * A URL to the package archive (e.g. `https://github.com/my-org/my-auth-provider/archive/master.zip`)
* `install_args` You may pass additional arguments to the `pip install` command used to install your plugin.


{%note title=Note%}
When the term *plugin* is used in this section, it should not be confused with operation and workflow plugins (except when explicitly mentioned otherwise).

When we use this term here, we simply mean: custom code that gets installed in the manager environment. In other words, plugins here cannot be used as operations and workflows plugins.
{%endnote%}
