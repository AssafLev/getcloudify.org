---
layout: bt_wiki
title: Security Guide
category: Guides
publish: true
abstract: Cloudify's Management security configuration and client usage
pageord: 500

---
{%summary%} {{page.abstract}}{%endsummary%}

# Overview

This guide will explain how to bootstrap a secured manager and use it from the CLI and web UI. <br>
Securing the manager focuses on the REST service, which is the access point of all clients to the management server.

Cloudify's security framework uses the [Flask-secuREST](https://github.com/cloudify-cosmo/flask-securest/tree/0.6)
package, which integrates with [Flask-RESTful](https://flask-restful.readthedocs.org/en/0.3.2/) to secure REST services.

When security is enabled, all requests to the REST service are authenticated before they can reach their endpoint
(except internal requests, as explained in the Advanced section below).<br>
For example, when a user of the Web-UI attempts to see the all blueprints, a request is sent to the REST service
"blueprints" endpoint, but it will only reach it if the user is logged in with valid credentials. <br>
Similarly, the CLI command "cfy deployments create" will only be successful if valid
credentials are sent with the REST call to the endpoint "deployments".
Of course, direct requests made using other clients (e.g. curl) must also include correct credentials, or they will
fail with an "Unauthorized User" error.


# Main Concepts

## Userstore
Generally, a userstore is simply a class that enables loading of user details and returns them as a user object.

Typically (but not always) user details are stored as records in a database or objects in a directory. Each user can
be identified by a unique attribute, such as a username or id, or by a unique combination of attributes.<br>
In order to authenticate a user (for example by a set of username and password) it might be required to load the user's
details and verify the given credentials indeed match.<br>
To support a variety of user-store systems and configurations Cloudify security framework can accept different
userstore implementations. It's possible to use the default Flask-secuREST simple userstore or to specify a new
implementation that supports a specific userstore system.


## Authentication Provider
An Authentication Provider is a class that performs authentication. Multiple authentication providers can be configured
in order to support multiple authentication methods (e.g. password, token, Kerberos).<br>
When a REST call is received by the REST service, the security framework will attempt to authenticate it using the
configured authentication providers. If the first authenticator fails the second one will be attempted, and so on.
The authentication provider has access to the userstore instance (if configured) and can use it to get user details and
use them to perform authentication.<br>
For example, it can compare the given password to the one found on the userstore or verify the user is still active
(in many environments users are marked as "inactive", instead of deleting the account entirely).


Once an authenticator can successfully authenticate the request's user - it should return the user object and allow the
request to be completed. Other authenticators will not be called until the next request is processed.
If none of the authenticators can successfully authenticate the request - the request does not reach its endpoint and
the client receives an "Unauthorized User" error.


## Token Generator
We mentioned Token as an authentication method. But in order to send a token with each request, the user must first
receive a token. Tokens can be generated by many systems, and they will work as long as the token can be processed by
one of the registered authentication providers.


To make things easier, Cloudify can also generate tokens through the REST service endpoint "/tokens".
To enable this feature a token generator must be configured.

{% note title=Note %}
The request to "/tokens" must itself be authenticated (using a username-password set, for example).
{% endnote %}


# Setting up a secured server

## Manager Blueprint Configuration
The security configuration is located in the manager blueprint, in this path:
{% highlight yaml %}
node_templates
  ...
  manager
    ...
    properties
      ...
      cloudify
        ...
        security
{% endhighlight %}
Each setting is described in detail in the following sections.

### Setting Security On / Off
The first setting in the "security" path is:

{% highlight yaml %}
enabled: false
{% endhighlight %}

This means security is turned off. In order to activate the security framework set {% highlight yaml %}enabled: true{% endhighlight %}
Otherwise, all other security configuration will be ignored.

### Configuring Authentication Providers
Under `authentication_providers` is a list all the authenticators *In the order they should be executed*.<br>
At least one authentication provider must be configured.

Each authentication provider must include these properties:

- name - a unique name describing this authenticator. This name will appear in logs so it should be clear.
- implementation - the fully qualified name of a module implementing an authentication provider, followed by ":" and
the class name.
- properties - a dictionary of arguments required to instantiate the authentication provider class. The arguments will
be passed as kwargs to the class' `__init__` method.

The default configuration uses two authentication methods - password and token:

{% highlight yaml %}
authentication_providers:
  - name: password
    implementation: flask_securest.authentication_providers.password:PasswordAuthenticator
    properties:
      password_hash: plaintext
  - name: token
    implementation: flask_securest.authentication_providers.token:TokenAuthenticator
    properties:
      secret_key: my_secret
{% endhighlight %}

The above configuration will cause the security framework to instantiate two classes:

- Flask-secuREST's "PasswordAuthenticator", with the `password_hash` argument set to "plaintext".
{%note title=Note%}
Passwords are usually not stored as plaintext. Set `passowrd_hash` to match the hash scheme used
in the selected userstore.
Possible values are: 'bcrypt', 'des_crypt', 'pbkdf2_sha256', 'pbkdf2_sha512', 'sha256_crypt' and 'sha512_crypt'.
{%endnote%}
This authentication check will be performed first for each request sent to the REST service. If it fails, the next
authenticator will be used.

- Flask-secuREST's "TokenAuthenticator", with the `secret_key` argument set to "my_secret".
The secret key is used to decrypt the token sent with the request, if a token was sent.
{%note title=Note%}
When selecting a token authenticator, it is required to verify it supports the tokens generated by your token generator
(which might be implmeneted elsewhere entirely).
{%endnote%}

It is possible to implement many other authentication providers, including providers that do not require accessing a
userstore directly (e.g. oAuth). This is explained later in this document.

### Configuring a Userstore
Under "userstore_driver" a single userstore is set:

- implementation - the fully qualified name of the module implementing a userstore integration, followed by ":" and the
class name.
- properties - a dictionary of arguments required to instantiate the implementing class. The arguments will be passed as
kwargs to the class' `__init__` method.

The default configuration uses Flask-secuREST's simple userstore, with an in-line list of users:

{% highlight yaml %}
userstore_driver:
  implementation: flask_securest.userstores.simple:SimpleUserstore
  properties:
    userstore:
      user1:
        username: example_user1
        password: example_password1
        email: example_user1@your_domain.dom
      user2:
        username: example_user2
        password: example_password2
        email: example_user2@your_domain.dom
      user3:
        username: example_user3
        password: example_password3
        email: example_user3@your_domain.dom
    identifying_attribute: username
{% endhighlight %}

In the default configuration a userstore is created on the fly, containing the 3 listed users. The identifying
attribute (by which a user can be identified) is set to "username".
This is a very simple implementation useful for demonstration. To integrate with a "real" userstore a different
implementation can be created and installed, as explained later.


### Configuring a Token Generator
In order to enable token generation through the REST "/tokens" endpoint a token generator must be configured:

- implementation - the fully qualified name of the module implementation token generation, followed by ":" and the
class name.
- properties - a dictionary of arguments required to instantiate the implementing class. The arguments will be passed as
kwargs to the class' `__init__` method.

The default configuration uses Flask-secuREST's token module to generate tokens:

{% highlight yaml %}
auth_token_generator:
  implementation: flask_securest.authentication_providers.token:TokenAuthenticator
  properties:
    secret_key: my_secret
    expires_in_seconds: 600
{% endhighlight %}

{%note title=Note%}
In the default TokenAuthenticator implementation, the key used for token authentication is the same as the key used to
generate it. This means you should set the same `secret_key` here and in `authentication_providers`.
{%endnote%}

The configuration includes the additional argument `expires_in_seconds` which limits the lifetime of a token
to 10 minutes. A token older than 10 minutes will therefore be expired and fail the request (a feature of the default
token generator implementation).


### SSL
It is possible to interact with a manager that is secured by [SSL](http://en.wikipedia.org/wiki/Transport_Layer_Security).

The SSL configuration is located under `ssl`.<br>
This is the default SSL configuration:
  {% highlight yaml %}
  ssl: {
    enabled: false,
    certificate_path: '',
    private_key_path: ''
  }
  {% endhighlight %}
  This means that SSL is turned off, the manager will not be secured by SSL protocol and all requests to it will be made over port 80 using the protocol 'http'.

  To enable an SSL connection set `enabled` to `true` and specify the certificate and key paths:
  {% highlight yaml %}
    ssl: {
      enabled: true,
      certificate_path: path-to-certificate,
      private_key_path: path-to-private-key
    }
  {% endhighlight %}
  This means that the manager will be secured by SSL with the given certificate and key.<br>
  It also means that every request to the manager must be on port 443 using the 'https' protocol 
  and that the certificate will be sent to any client that asks to verify it. 

{%tip title=Using a self-signed certificate%}

  A [self-signed certificate](http://en.wikipedia.org/wiki/Self-signed_certificate) can be used- this is a certificate that is signed by the manager itself, not by a CA (certificate authority)<br>
  In this case, every client that wants to verify the manager's certificate needs to recieve a copy of the certificate file in order to use it for verification (see [Manager's certificate verification](#ssl-cli-configuration) )


  The following command can be used for creating a self-sigend certificate: 
  {% highlight bash %}
    openssl req -x509 -newkey rsa:2048 -keyout key.pem -out certificate.pem -days 365 
  {% endhighlight %}
  For more information see [The openssl req command](https://www.openssl.org/docs/apps/req.html).
{%endtip%}

{%note title=The certificate's CommonName%}
  If certificate verification is expected by clients, the certificate's common name should be consistent with the manager's ip, because the SSL verification process denies certificates where the common name does not match the URL and all requests to the manager will use the manager's ip as the URL.<br>
  If no certificate verification is expected, then the only requirment is to specify paths to valid certificate and key files (with any common name).
{%endnote%}


### Logging
Security operations, such as authentication success or failure and user details, are audited in dedicated log file on
the management container.
The default configuration is:

{% highlight yaml %}
audit_log_file: /var/log/cloudify/rest-security-audit.log
audit_log_level: INFO
log_file_size_MB: 100
log_files_backup_count: 20
{% endhighlight %}

- Modifying the log level will produce less or more elaborate security auditing; The acceptable values are:
CRITICAL, ERROR, WARNING, INFO or DEBUG.
- audit_log_file_size_MB - limits the log file size. By default, the file is limited to 100 MB. When the file reaches
that size, it will be renamed with the extension ".1" and a new log file will be created.
- audit_log_files_backup_count - sets the maximum number of old log files to keep. By default this value is set to 20.
That means that up to 20 old log files can be created, after which the oldest file will be removed.


# Clients

Different clients can be used to send requests to the REST service, and all go through an authentication process.
Here we review what each client requires in order to send a secured request.


## Web UI
Login - with username and password

{%note title=Note%}
This client only supports authentication with username-password.
{%endnote%}

{%note title=Note%}
Available in the Commercial version only
{%endnote%}

## Cloudify CLI: cfy commands
cfy commands that connect to the REST service (e.g. "deployments create") send username and password in a header on each
request. Setting these values is done once, via these environment variables:

 - CLOUDIFY_USERNAME
 - CLOUDIFY_PASSWORD

### SSL CLI configuration

#### Connect with a manager secured by SSL:
  - After bootstrap, every request to the secured manager will be on port 443, using the 'https' protocol.
  - The `use` command requires specifing the port option to be 443 
      <br>e.g. 
      {% highlight bash %}
        'use -t <manager-ip-address> --port 443'
      {% endhighlight %}

#### Manager's certificate verification:
By default, the manager's certificate will be verified.<br>
There are two environment variables that can be set:
  
  - `CLOUDIFY_SSL_TRUST_ALL` - set to any non empty value to avoid certificate verification.
  - `CLOUDIFY_SSL_CERT_PATH` - set the path to a copy of the manager's certificate in case verification is wanted (trust all is not set) and the manager's certificate is a self-signed certificate. 


{%note title=Note%}
This client only supports authentication with username-password
{%endnote%}

## Other REST clients
other REST clients (e.g. cURL) must explicitly add credentials to each request.<br>
For example:

 - Get the server status, authenticate with username and password:<br>
curl -u 'MY_USERNAME':'MY_PASSWORD' MANAGER_IP/status
 - Get a token, authenticate with username and password:<br>
curl -u 'MY_USERNAME':'MY_PASSWORD' MANAGER_IP/tokens
 - Get all the blueprints, authenticate with a token:<br>
curl -H 'Authentication-Token:MY_TOKEN' MANAGER_IP/blueprints


# Behind the Scenes / Advanced

## Secured Request Flow

![request-flow](/guide/images3/guide/request_flow.png)

## Internal communication between the Cloudify manager and other Cloudify components

Currently, communication between the Cloudify agents and the Cloudify manager does not go through authentication - instead, REST calls from the agents to the manager are done to port 8101, which has the same general behavior as port 80, yet the REST service lets requests made to this port through without having them go through any of the security mechanisms.

The usage of this port, however, is restricted to components on the same subnet as the Cloudify manager alone. This is done using specific security group rules, which are set up during bootstrap (for example, see [this rule in the Openstack manager blueprint](https://github.com/cloudify-cosmo/cloudify-manager-blueprints/blob/master/openstack/openstack-manager-blueprint.yaml#L206)). It is therefore impossible to bypass the security mechanisms from outside the manager's internal network by making REST calls directly to the 8101 port.

In future versions, all communications from and to the Cloudify manager will utilize the security mechanisms, including communication with any of Cloudify's internal components, at which time, the bypass port 8101 will be removed.


## Advanced configuration (logs, token timeout, password hashing, nginx)

# Writing your own userstore and authentication providers

## Custom UserStore Implementation

A valid userstore implementation can be any Python class that inherits from
[abstract_userstore.py](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/userstores/
abstract_userstore.py) and implements: 

- get_user() - returns a relevant user from the userstore. If a matching user is not found, returns None.<br>
  The object returned by `get_user` must adhere to Flask-secuREST's [User Model](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/models.py#L41).

### LDAP UserStore Example:
  An example for a userstore class - [LDAPUserStore](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/userstores/examples/ldap_userstore.py).<br>
  This class inherits from [AbstractUserstore](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/userstores/abstract_userstore.py) and implements the `get_user` method as required. 

  The properties to initialize this class should be specified in the manager blueprint as described earlier in [Configuring a Userstore](#configuring-a-userstore).<br>
  For example:
  {% highlight yaml %}
  userstore_driver:
    implementation: flask_securest.authentication_providers.ldap_userstore:LDAPUserStore
    properties:
      admin_dn: cloudify.org
      admin_password: password
      directory_url: ldap://localhost:389
      root_dn: dc=cloudify,dc=org
      identifying_attribute: uid
      username_attribute: uid
      user_password_attribute: userPassword
      user_email_attribute: mail
      is_active_attribute: is_active
  {% endhighlight %}
  The above properties are specific to this example implementation.

  In order to use this custom userstore the implementation of LDAPUserStore class should be installed on the manager as describe in [Packaging, Configuring and Installing Custom Implementations](packaging-configuring-and-installing-custom-implementations).


## Custom authentication provider Implementation

A valid authentication provider implementation can be any Python class that inherits from
[AbstractAuthenticationProvider](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/
authentication_providers/abstract_authentication_provider.py) and implements an `authenticate` method.

### Password Based Authentication Provider Example:
  An example for authentication provider - [PasswordAuthenticator](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/authentication_providers/password.py)
  This class implements an authentication provider based on password authentication. 
  The `authenticate` method compares the password given from the user store (using the `get_user()` method) with the one recieved from the user (on the request).

  The properties to initialize this class should be specified in the manager blueprint as described earlier in [Configuring Authentication Providers](#configuring-authentication-providers).<br>

## Packaging, Configuring and Installing Custom Implementations

In order to use custom implementations of userstores, authentication providers and token generators; the implementations themselves should be installed on the manager.

To do this, the manager blueprint should be updated as follows.

Say you write a custom authentication provider. The code itself should be structured in a similar way to how [operations/workflows](guide-plugin-creation.html#creating-a-plugin-project) plugins are structured, that is to say, it should be structured as a valid python package.

You specify the package location under the `plugins` section in the `cloudify` property of the `manager` node in the manager blueprint like this:
{% highlight yaml %}
node_templates:
  ...
  manager:
    ...
    properties:
      ...
      cloudify:
        plugins:
          my_authentication_provider:

            # see description below
            source: my-extensions/simple-authentication-provider

            # see description below
            install_args: '--pre'

          my_userstore:

            # see description below
            source: https://github.com/my-org/my-auth-provider/archive/master.zip

{% endhighlight %}


### Configuration
The `plugins` section is a dict that contains all plugins that should be installed.

The keys of this dict are arbitrary names. In the previous example we used `my_authentication_provider` and `my_userstore` as the names.

* `source` Can be any of the following:
  * A path to the package directory relative to the [main manager blueprint file](reference-terminology.html#main-blueprint-file) directory (e.g. `my-extensions/simple-authentication-provider`)
  * A URL to the package archive (e.g. `https://github.com/my-org/my-auth-provider/archive/master.zip`)
* `install_args` You may pass additional arguments to the `pip install` command used to install your plugin.


{%note title=Note%}
When the term *plugin* is used in this section, it should not be confused with operation and workflow plugins (except when explicitly mentioned otherwise).

When we use this term here, we simply mean: custom code that gets installed in the manager environment. In other words, plugins here cannot be used as operations and workflows plugins.
{%endnote%}
